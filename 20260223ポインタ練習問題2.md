# 問題1
次の関数を作れ。
int* make_ptr();
条件：
関数内で整数を1つ用意する
そのアドレスを返す
mainでそのポインタを使って値を表示する

```mondai1.c
#include<stdio.h>

int* makeptr(){
 int num=55;
 int* ptr=&num;
 return ptr;
}

void func(){
 int arr[]={1,2,3,4,5,6,7,8,9,10,11}; 
}

void main(){
 int* ptr=makeptr();
 printf("ptr=%d\n",*ptr);

 func();

 printf("ptr=%d\n",*ptr);
}
```
<img width="1920" height="1080" alt="截图 2026-02-23 18-29-51" src="https://github.com/user-attachments/assets/287d31e1-c689-423d-bef3-112f720dafd3" />


```mondai1-2.c
#include<stdio.h>

int* makeptr(){
 int* ptr=(int *)malloc(4);
 *ptr = 55;
 return ptr;
}

void func(){
 int arr[]={1,2,3,4,5,6,7,8,9,10,11}; 
}

void main(){
 int* ptr=makeptr();
 printf("ptr=%d\n",*ptr);

 func();

 printf("ptr=%d\n",*ptr);
}
```
<img width="1920" height="1080" alt="截图 2026-02-23 18-31-29" src="https://github.com/user-attachments/assets/86843322-a3fe-446a-94ab-a0b3473e63f2" />

# 問題2（ポインタのポインタ）
void redirect(int **pp);
main：
int a = 10;
int b = 20;
int *p = &a;
redirect(&p);
実行後：
*p == 20
条件：
グローバル変数禁止
mainの変数を直接触れない
関数内で完結させる

```mondai2.c
#include<stdio.h>

void redirect(int **pp,int *p){
 **pp=*p;
}

void main(){
 int a=10;
 int b=20;
 int *p=&a;
 redirect(&p,&b);
 
 printf("*p=%d \n",*p);
}
```
<img width="1920" height="1080" alt="截图 2026-02-23 18-31-49" src="https://github.com/user-attachments/assets/f3a8e2b9-9381-4cf2-a445-f50d4d1a0597" />

#  問題3（配列の本質）
void advance(int **pp);

main：

int arr[5] = {10,20,30,40,50};
int *p = arr;

advance(&p);
printf("%d\n", *p);
出力が20になるようにする。
※ arr[i] 使用禁止

```mondai3.c
#include<stdio.h>

void advance(int **pp){
  *pp = *pp+1;
}

void main(){
 int arr[5]={10,20,30,40,50};
 int *p=arr;
 advance(&p);
 printf("*p=%d",*p);
}
```
<img width="1920" height="1080" alt="截图 2026-02-23 18-32-02" src="https://github.com/user-attachments/assets/54e3a52e-14d8-4b3e-87e6-0b10d9df17c2" />

# 問題4（メモリ走査）
関数：
int count_value(int *p, int size, int value);
配列内に value が何個あるか数える。
条件：
添字禁止
ポインタ移動のみ

```mondai4.c
#include<stdio.h>

int countvalue(int *p, int size,int value){
 int cnt=0;
 while(size != 0){
  if(*p++ == value){
   cnt++;
  }
  size--;
 }
 return cnt;
}

void main(){
 int arr[8]={10,20,30,40,50,30,30,10};
 int *p=&arr;
 int cnt = countvalue(p,8,30);
 printf("cnt=%d\n",cnt);
}
```
<img width="1920" height="1080" alt="截图 2026-02-23 18-32-23" src="https://github.com/user-attachments/assets/f1b5311c-1e1f-4f0d-be40-77e1f2e3b331" />

# 問題5
関数：
char* find_char(char *s, char c);
条件：
見つかった位置のポインタを返す
なければ NULL
添字禁止
ポインタのみで探索

```mondai5.c
#include<stdio.h>

char* findchar(char *s, char c){
 char *ret=NULL;
 while(*s!='\0'){
  if(*s==c){
   ret=s;
   break;
  }
  s++;
 }
 return ret;
}

void main(){
 char str[]="aiueo";
 char c = 'e';
 char *ptr = findchar(&str,c);
 printf("*ptr=%c",*ptr);
}
```

<img width="1920" height="1080" alt="截图 2026-02-23 18-32-42" src="https://github.com/user-attachments/assets/09336bff-6837-4dc3-b49d-76f82d67f2d2" />

# 問題6（ヒープとポインタ）

関数を作れ：
int* make_array(int size);
条件
size 個の int を動的に確保する
配列の中身は次のように初期化
0, 1, 2, 3, ... size-1
先頭アドレスを返す

```mondai6.c
#include<stdio.h>

int* makearray(int size){
 int *array=malloc(sizeof(int)*size);
 int i;
 
 for(i=0;i<size;i++){
  array[i]=i;
 }
 return array;
}

void main(){
 int *p=makearray(5);
 
 int i;
 for(i=0;i<5;i++){
  printf("p[%d]=%d\n",i,*p+i);
 }
}
```

<img width="1920" height="1080" alt="截图 2026-02-23 18-32-57" src="https://github.com/user-attachments/assets/efb63412-4f41-4f16-bc5f-e1f23de61feb" />

# 問題7

次の関数を作れ。
int* make_numbers(int size);
条件
size 個の int を動的確保する
中身はすべて 100 にする
先頭ポインタを返す

```mondai7.c
#include<stdio.h>

int* makenumbers(int size){
 int *array=malloc(sizeof(int)*size);
 int i;
 for(i=0;i<size;i++){
  array[i]=100;
 }
 return array;
}

void main(){
 int *p=makenumbers(5);
 
 int i;
 /*
 for(i=0;i<5;i++){
  printf("p[%d]=%d\n",i,p[i]);
 }
 */
 printf("*p=%p p[0]=%d\n",(void *)p,p[0]);
 free(p);
 printf("*p=%p p[0]=%d\n",(void *)p,p[0]);
 free(p);
 printf("*p=%p p[0]=%d\n",(void *)p,p[0]);
}
```
<img width="1920" height="1080" alt="截图 2026-02-23 18-33-24" src="https://github.com/user-attachments/assets/695dd73e-5e1d-4483-a3ab-11ea697c81b3" />

freeしたら指しているアドレスの値が変わった。

# 問題8（二重ポインタ＋malloc）
次の関数を作れ。
int alloc_array(int **pp, int size);
仕様
size 個の int を動的確保する
確保に成功したら：
*pp に先頭アドレスを代入
配列の中身を次のように初期化

```mondai8.c
#include<stdio.h>

int distance(int *p1,int *p2){
 printf("p2=%d\n",p2);
 printf("p1=%d\n",p1);
 printf("p2-p1=%d\n",p2-p1);
 return (p2-p1);
}

void main(){
 int arr[10]={0,2,3,4,5,6,7,8,9};
 int d=distance(&arr[2],&arr[7]);
 printf("d=%d",d);
}
```
<img width="1920" height="1080" alt="截图 2026-02-23 18-33-40" src="https://github.com/user-attachments/assets/f1766660-d549-4300-87be-bd0db84a5a9a" />

ポインタの差はバイト数になると思っていたが要素数だった。

# 風景

![9701843fc8206](https://github.com/user-attachments/assets/965be566-417d-4a85-ac8a-f6a1dd61899c)
